// Copyright 2021 Maple512 and Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License"),
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace OneF.Mappable;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using OneF.Mappable.Internal;

public readonly struct TypeMapInfo
{
    public TypeMapInfo(INamedTypeSymbol type) : this()
    {
        Type = type;
        Name = type.ToString();
        SortName = Name.Split('.').Last();
        Properties = type.GetMembers().OfType<IPropertySymbol>();

        Namespace = type.ContainingNamespace.ToString();
    }

    public INamedTypeSymbol Type { get; }

    public string Name { get; }

    public string SortName { get; }

    public string Namespace { get; }

    public IEnumerable<IPropertySymbol> Properties { get; }
}

public readonly struct TypeMapItemContext
{
    public TypeMapItemContext(INamedTypeSymbol sourceType, INamedTypeSymbol destinationType)
    {
        SourceType = new TypeMapInfo(sourceType);
        DestinationType = new TypeMapInfo(destinationType);
    }

    public TypeMapInfo SourceType { get; }

    public TypeMapInfo DestinationType { get; }
}

public class TypeMapContext
{
    private const string _sourceVar = "source";
    private const string _destinationVar = "destinaion";

    private static readonly HashSet<string> _usings = new();
    private static readonly HashSet<string> _staticFields = new();

    public TypeMapContext(Compilation compilation, ImmutableArray<ClassDeclarationSyntax?> data)
    {
        foreach(var classDeclaration in data.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration!.SyntaxTree);

            if(semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol sourceTypeSymbol)
            {
                // report diagnostic, something went wrong
                throw new Exception("某种未知错误，修复后，移除该代码，使用continue");

                continue;
            }

            var sourceTypeProperties = sourceTypeSymbol.GetMembers().OfType<IPropertySymbol>();

            var attributeDatas = sourceTypeSymbol.GetAttributes()
                .Where(x => Constants.AttributeFullNames.Contains(x.AttributeClass!.ToString()));

            foreach(var attribute in attributeDatas)
            {
                var destinationTypeName = attribute!.ConstructorArguments.FirstOrDefault().Value!.ToString();

                var destinationType = compilation.GetTypeByMetadataName(destinationTypeName)!;

                TypeMapItemContext typeMapContext;
                if(attribute.AttributeClass!.ToString() == Constants.AutoMapToFullName)
                {
                    typeMapContext = new TypeMapItemContext(sourceTypeSymbol, destinationType);
                }
                else
                {
                    typeMapContext = new TypeMapItemContext(destinationType, sourceTypeSymbol);
                }

                Items.Add(typeMapContext);
            }
        }
    }

    public ICollection<TypeMapItemContext> Items { get; } = new List<TypeMapItemContext>();

    public IndentedStringBuilder Builder(CancellationToken token)
    {
        var content = new IndentedStringBuilder();

        _ = content.AppendLine($"// <auto-generated>");

        _ = content.AppendLine();
        _ = content.AppendLine("namespace OneF.Mappable;");
        _ = content.AppendLine();

        var methodContent = new IndentedStringBuilder();
        _ = methodContent.IncrementIndent();
        foreach(var item in Items)
        {
            token.ThrowIfCancellationRequested();

            BuildMapCode(methodContent, item);
        }

        foreach(var @using in _usings.OrderBy(x => !x.StartsWith(nameof(System))).ThenBy(x => x))
        {
            _ = content.AppendLine($"using {@using};");
        }

        _ = content.AppendLine();
        _ = content.AppendLine($"public static class {Constants.ExtensionsClassName}");
        _ = content.AppendLine("{");
        _ = content.IncrementIndent();
        if(_staticFields.Any())
        {
            foreach(var field in _staticFields.OrderBy(x => x))
            {
                // private readonly static _ = _;
                _ = content.AppendLine($"private readonly static {field};");
            }

            _ = content.AppendLine();
        }

        _ = content.DecrementIndent();
        _ = content.Append(methodContent.ToString());
        _ = content.AppendLine("}");

        return content;
    }

    internal static void BuildMapCode(IndentedStringBuilder content, TypeMapItemContext item)
    {
        _ = _usings.Add(item.SourceType.Namespace);
        _ = _usings.Add(item.DestinationType.Namespace);

        _ = content.AppendLine($"public static {item.DestinationType.SortName} To{item.DestinationType.SortName}(this {item.SourceType.SortName} {_sourceVar})");
        _ = content.AppendLine("{");
        _ = content.IncrementIndent();

        // 构建实例
        BuildCreateInstanceCode(content, item);

        // 设置属性
        foreach(var property in item.DestinationType.Properties)
        {
            var sourceProperty = item.SourceType.Properties.FirstOrDefault(x => x.Name == property.Name);

            var hasNotMapped = sourceProperty?.GetAttributes()
                .Any(x => x.AttributeClass?.ToString() == "System.ComponentModel.DataAnnotations.Schema.NotMappedAttribute");

            if(sourceProperty != null
                && hasNotMapped != true)
            {
                if(SymbolEqualityComparer.Default.Equals(property.Type, sourceProperty.Type))
                {
                    _ = content.AppendLine($"{_destinationVar}.{property.Name} = {_sourceVar}.{property.Name};");
                }
            }
        }

        _ = content.AppendLine($"return {_destinationVar};");

        _ = content.DecrementIndent();
        _ = content.AppendLine("}");
    }

    private static void BuildCreateInstanceCode(IndentedStringBuilder content, TypeMapItemContext item)
    {
        _ = content.Append($"var {_destinationVar} = ");

        // 公共无参构造函数
        var constructor = item.DestinationType.Type.InstanceConstructors
            .FirstOrDefault(x => x.Parameters.IsDefaultOrEmpty && x.DeclaredAccessibility == Accessibility.Public);

        if(constructor != null)
        {
            _ = content.AppendLine($"new {item.DestinationType.SortName}();");

            return;
        }

        // 无参构造函数
        constructor = item.DestinationType.Type.InstanceConstructors
            .FirstOrDefault(x => x.Parameters.IsDefaultOrEmpty);

        if(constructor != null)
        {
            _ = _usings.Add("System");
            _ = _usings.Add("System.Linq.Expressions");

            var field = $"_create{item.DestinationType.SortName}Func";

            _ = _staticFields.Add($"Func<{item.DestinationType.SortName}> {field} = Expression.Lambda<Func<{item.DestinationType.SortName}>>(Expression.New(typeof({item.DestinationType.SortName}))).Compile()");

            _ = content.AppendLine($"{field}.Invoke();");
            return;
        }

        constructor = item.DestinationType.Type.InstanceConstructors
                    .FirstOrDefault(x => x.DeclaredAccessibility == Accessibility.Public);

        throw new InvalidOperationException("未发现有效的构造函数，需要一个无参构造函数。");

        // 公共有参构造函数
        // 有参构造函数
    }
}
